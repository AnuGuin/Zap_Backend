API Specification for Zapnote Node Backend
Base path: /api

Authentication
- Type: Bearer Token (Firebase ID token)
- Header: Authorization: Bearer <ID_TOKEN>
- Protected routes return 401 Unauthorized when missing/invalid token.

Common error responses
- 400 Bad Request
  { "error": "..." }
- 401 Unauthorized
  { "message": "Unauthorized" } or { "message": "Invalid token" }
- 403 Forbidden
  { "message": "Access denied" } or { "message": "Insufficient permissions" }
- 404 Not Found
  { "message": "... not found" }
- 500 Internal Server Error
  { "error": "...", "details": "..." }

1) POST /knowledge/{workspaceId}/knowledge
- Description: Create a knowledge item from URL with AI processing (requires role: EDITOR)
- Auth: Bearer
- Path params:
  - workspaceId (string, required)
- Request body (application/json):
  {
    "url": "string",      // Required: URL to extract content from
    "intent": "string"    // Required: User's purpose/intent for saving this
  }
- Success Response 201 (application/json):
  {
    "message": "Knowledge item created and processing started",
    "data": {
      "id": "string",
      "title": "string",
      "content": "string | null",
      "summary": "string | null",
      "sourceUrl": "string",
      "type": "URL|PDF|TEXT|YOUTUBE|IMAGE",
      "status": "PENDING|PROCESSING|COMPLETED|FAILED",
      "metadata": {
        "excerpt": "string",
        "byline": "string",
        "siteName": "string",
        "publishedTime": "string",
        "favicon": "string",
        "userIntent": "string"
      },
      "workspaceId": "string",
      "createdAt": "ISO8601 datetime",
      "updatedAt": "ISO8601 datetime"
    }
  }
- Processing Pipeline (automatic):
  - Content extraction from URL
  - Chunking and embedding
  - AI summarization
  - Content classification
  - Entity extraction and enrichment
  - AI-powered tag generation based on content + intent
- Errors: 400 (missing url/intent), 401, 403, 500

2) GET /knowledge/{workspaceId}/knowledge
- Description: List all knowledge items in workspace with tags and entities (requires role: VIEWER)
- Auth: Bearer
- Path params:
  - workspaceId (string, required)
- Success Response 200 (application/json):
  [
    {
      "id": "string",
      "title": "string",
      "content": "string",
      "summary": "string | null",
      "sourceUrl": "string | null",
      "type": "URL|PDF|TEXT|YOUTUBE|IMAGE",
      "status": "PENDING|PROCESSING|COMPLETED|FAILED",
      "metadata": { /* optional metadata */ },
      "workspaceId": "string",
      "createdAt": "ISO8601 datetime",
      "updatedAt": "ISO8601 datetime",
      "tags": [
        { "id": "string", "name": "string" }
      ],
      "entities": [
        {
          "id": "string",
          "name": "string",
          "type": "string",
          "description": "string | null",
          "imageUrl": "string | null",
          "url": "string | null"
        }
      ]
    }
  ]
- Errors: 400/401/403/500

3) GET /knowledge/{workspaceId}/knowledge/{id}
- Description: Get single knowledge item with chunks, tags, and entities (requires role: VIEWER)
- Auth: Bearer
- Path params:
  - workspaceId (string, required)
  - id (string, required) - knowledge item id
- Success Response 200 (application/json):
  {
    "id": "string",
    "title": "string",
    "content": "string",
    "summary": "string | null",
    "sourceUrl": "string | null",
    "type": "URL|PDF|TEXT|YOUTUBE|IMAGE",
    "status": "PENDING|PROCESSING|COMPLETED|FAILED",
    "metadata": { /* metadata including userIntent */ },
    "workspaceId": "string",
    "createdAt": "ISO8601 datetime",
    "updatedAt": "ISO8601 datetime",
    "chunks": [
      {
        "id": "string",
        "content": "string",
        "metadata": { /* optional */ } | null,
        "knowledgeItemId": "string"
      }
    ],
    "tags": [
      { "id": "string", "name": "string" }
    ],
    "entities": [
      {
        "entityId": "string",
        "confidence": number,
        "entity": {
          "id": "string",
          "name": "string",
          "type": "string",
          "description": "string | null",
          "imageUrl": "string | null",
          "url": "string | null"
        }
      }
    ]
  }
- Errors: 400/401/403/404/500

4) POST /search/{workspaceId}
- Description: Semantic search across workspace documents
- Auth: Bearer
- Path params:
  - workspaceId (string, required)
- Request body (application/json):
  {
    "query": "string",
    "limit": integer (optional, default 10)
  }
- Success Response 200 (application/json):
  {
    "results": [
      {
        "id": "chunk id",
        "content": "string",
        "documentId": "string",
        "similarity": number (0..1)
      }
    ]
  }
- Notes: Implementation uses embeddings & vector similarity; ensure indexing/ingestion has run.
- Errors: 400/401/403/500

5) POST /spaces/{workspaceId}/spaces
- Description: Create a space (requires role: EDITOR)
- Auth: Bearer
- Path params:
  - workspaceId (string, required)
- Request body (application/json):
  { "name": "string" }
- Success Response 201 (application/json):
  {
    "id": "string",
    "name": "string",
    "workspaceId": "string",
    "createdAt": "ISO8601 datetime",
    "updatedAt": "ISO8601 datetime"
  }
- Errors: 400/401/403/500

6) GET /spaces/{workspaceId}/spaces
- Description: List spaces in a workspace (requires role: VIEWER)
- Auth: Bearer
- Path params:
  - workspaceId (string, required)
- Success Response 200 (application/json):
  [ { space object as above } ]
- Errors: 400/401/403/500

7) POST /chat/{workspaceId}
- Description: RAG chat against workspace knowledge (requires role: VIEWER)
- Auth: Bearer
- Path params:
  - workspaceId (string, required)
- Request body (application/json):
  {
    "message": "string",                 // required
    "documentId": "string",              // optional, narrow search to a document
    "history": [                           // optional chat history to include
      { "role": "user" | "model", "content": "string" }
    ]
  }
- Success Response 200 (application/json):
  {
    "response": "string",                // LLM answer
    "sources": [                           // retrieved context chunks
      { "id": "chunk id", "content": "string", "documentId": "string", "similarity": number }
    ]
  }
- Errors:
  - 400 if missing message
  - 401/403/500 as applicable

8) GET /health
- Description: Health check (no auth)
- Success Response 200:
  { "status": "ok" }

Auth / User mapping details (middleware behavior)
- `authenticate` middleware verifies Firebase ID token and ensures a `User` exists in DB:
  1. Verify ID token via Firebase Admin SDK.
  2. Extract `uid`, `email`, `name` from token.
  3. Try to find user by `id = uid`.
     - If found, update email/name if changed.
     - If not found, attempt to find user by email (legacy linking).
       - If found by email, keep that user id (legacy UUID) and update name if changed.
       - If not found, create user with `id = uid`, `email`, `name`.
  4. Attach `req.user = { id, email }` for downstream handlers.

Testing guidance
- Obtain Firebase ID token from client after sign-in (Email/Password or Google) and pass in `Authorization` header.
- Example: Create knowledge item from URL:

  curl -X POST "http://localhost:3000/api/knowledge/{workspaceId}/knowledge" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer <ID_TOKEN>" \
    -d '{"url": "https://example.com/article", "intent": "Research for my AI project"}'

- Example: Chat with RAG:

  curl -X POST "http://localhost:3000/api/chat/{workspaceId}" \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer <ID_TOKEN>" \
    -d '{"message": "What is in document X?", "documentId": "..."}'

- Processing is asynchronous via BullMQ workers. Monitor status field (PENDING → PROCESSING → COMPLETED).
- Ensure Redis is running for queue processing and all workers are initialized.

Notes / Implementation caveats
- Vector operations use raw SQL with `vector` extension; ensure DB has the extension and chunk embeddings stored as `vector`.
- LLM and embedding SDK calls are in `src/ai/*`. Uses Google Vertex AI (Gemini models).
- Content extraction uses Mozilla Readability + JSDOM for clean text extraction.
- Entity enrichment uses Google Knowledge Graph API (requires GOOGLE_API_KEY in .env).
- Role-based access enforced by `authorizeWorkspace` middleware which reads `WorkspaceMember` role.
- Background processing uses BullMQ with Redis:
  - ingest: Extracts content from URL, creates chunks
  - embed: Generates vector embeddings
  - summarize: AI-powered summarization
  - classify: Content classification
  - enrichment: Entity extraction and Knowledge Graph enrichment
  - generate-tags: AI tag generation based on content + user intent

File: apispec.txt
- This file (created at project root) contains the above human-readable API spec for quick testing and Postman import.

